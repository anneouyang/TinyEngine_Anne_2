/* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for normal convolution 5x5
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_math.h"
#include "arm_nnsupportfunctions.h"
#include "arm_nnfunctions.h"
//#include "kernel_buffer.h"
#include "kernel_element.h"
#include "img2col_element.h"
#include "tinyengine_function.h"
tinyengine_status convolution_s8_kernel5x5_stride2_pad2x2_input1(q7_t *input, const uint16_t input_x, const uint16_t input_y,
				const uint16_t input_ch, const q7_t *kernel, const int32_t *bias,
				const int32_t *output_shift, const int32_t *output_mult,
				const int32_t output_offset, const int32_t input_offset,
				const int32_t output_activation_min,
				const int32_t output_activation_max, q7_t *output,
				const uint16_t output_x, const uint16_t output_y,
				const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value)
{

    int16_t i, j, i_out_y, i_out_x, cnt;

    /* Generate two columns from the matrix multiplication */
	q15_t *two_column_buf = runtime_buf;
	q7_t *out = output;

	q15_t pad16 = pad_value;
	const int16_t inoff16 = input_offset;
	q15_t pad_out = pad16 + inoff16;
	q31_t pad_out_q15x2 = __PKHBT(pad_out, pad_out, 16);
	q31_t offset_q15x2 = __PKHBT(inoff16, inoff16, 16);
    for (i_out_y = 0; i_out_y < output_y; i_out_y++) {
		for (i_out_x = 0; i_out_x < output_x; i_out_x++) {
            /* This part implements the optimized im2col function */
			const int16_t base_idx_y = (i_out_y  * 2) - 2;
			const int16_t base_idx_x = (i_out_x  * 2) - 2;
			const q15_t *col_buffer = two_column_buf;

			//use variables
			q31_t in_q7x4;
			q31_t in_q15x2_1;
			q31_t in_q15x2_2;
			q31_t out_q15x2_1;
			q31_t out_q15x2_2;

			/* load address:8bit */
            q7_t *src0;
            q7_t *src1;
            q7_t *src2;
            q7_t *src3;
            q7_t *src4;
			/* buffer for load:16bit */
			q15_t *dst0 = &col_buffer[5 * input_ch * 0];
			q15_t *dst1 = &col_buffer[5 * input_ch * 1];
			q15_t *dst2 = &col_buffer[5 * input_ch * 2];
			q15_t *dst3 = &col_buffer[5 * input_ch * 3];
			q15_t *dst4 = &col_buffer[5 * input_ch * 4];
            int input_row_offset = input_ch * input_x;
            //load 
            if (base_idx_y >= 0) {
                if (base_idx_x >= 0) {
                    //5 elements, kernel_w * input_ch
                    src0 = input + (base_idx_y * input_x + base_idx_x) * input_ch;
                    src1= src0 + input_row_offset;
                    src2= src1 + input_row_offset;
                    src3= src2 + input_row_offset;
                    src4= src3 + input_row_offset;
                    //5 = 4 * 1 + 1
                    q7_q15_offset_ele(src0, dst0)
					*dst0++ = *src0++ + input_offset;
                    q7_q15_offset_ele(src1, dst1)
					*dst1++ = *src1++ + input_offset;
                    q7_q15_offset_ele(src2, dst2)
					*dst2++ = *src2++ + input_offset;
                    q7_q15_offset_ele(src3, dst3)
					*dst3++ = *src3++ + input_offset;
                    q7_q15_offset_ele(src4, dst4)
					*dst4++ = *src4++ + input_offset;
                } else {
                    src0 = input + (base_idx_y * input_x) * input_ch;
                    src1= src0 + input_row_offset;
                    src2= src1 + input_row_offset;
                    src3= src2 + input_row_offset;
                    src4= src3 + input_row_offset;
                    cnt = base_idx_x * -1;
                    while (cnt--){
                        *dst0++ = pad_out;
                        *dst1++ = pad_out;
                        *dst2++ = pad_out;
                        *dst3++ = pad_out;
                        *dst4++ = pad_out;
                    }
                    cnt = base_idx_x + 5;
                    while (cnt--){
                        *dst0++ = *src0++ + input_offset;
                        *dst1++ = *src1++ + input_offset;
                        *dst2++ = *src2++ + input_offset;
                        *dst3++ = *src3++ + input_offset;
                        *dst4++ = *src4++ + input_offset;
                    }
                }
            } else {
                cnt = base_idx_y * -1;
                while (cnt--){
                    *dst0++ = pad_out;*dst0++ = pad_out;*dst0++ = pad_out;*dst0++ = pad_out;*dst0++ = pad_out;          
                }
                if (base_idx_x >= 0) {
                    for (i = 0; i < 5 + base_idx_y; i++){//rows
					    src0 = input + (base_idx_x) * input_ch + input_row_offset * i;
                        cnt = 5;
                        while(cnt--){
                            *dst0++ = *src0++ + input_offset;
                        }
                    }
				} else {
                    for (i = 0; i < 5 + base_idx_y; i++){//rows
					    src0 = input + input_row_offset * i;
                        cnt = input_ch * base_idx_x * -1;
                        while(cnt--){
                            *dst0++ = pad_out;
                        }
                        cnt = (5 + base_idx_x) * 1;
                        while(cnt--){
                            *dst0++ = *src0++ + input_offset;
                        }
                    }
				}
            }
            //handle the most right and most bottom
            if (base_idx_x > input_x - 5){
				cnt = base_idx_x - (input_x - 5);
                dst0 = &col_buffer[input_ch * (5-cnt)];
                dst1 = dst0 + 5* input_ch;
                dst2 = dst1 + 5* input_ch;
                dst3 = dst2 + 5* input_ch;
                dst4 = dst3 + 5* input_ch;
                while(cnt--){
                    *dst0++ = pad_out;
                    *dst1++ = pad_out;
                    *dst2++ = pad_out;
                    *dst3++ = pad_out;
                    *dst4++ = pad_out;
                }
            }
            if (base_idx_y > input_y - 5){
				cnt = base_idx_y - (input_y - 5);
            	dst0 = &col_buffer[5 * input_ch * (5-cnt)];
            	while(cnt--){
                    *dst0++ = pad_out;
                    *dst0++ = pad_out;
                    *dst0++ = pad_out;
                    *dst0++ = pad_out;
                    *dst0++ = pad_out;
            	}
            }
            two_column_buf += 25;
			/* Computation is filed for every 2 columns */
			if (two_column_buf == runtime_buf + 2 * 25) {
				out = mat_mult_kernel_s8_s16(kernel,
						runtime_buf, output_ch, output_shift, output_mult,
						output_offset, output_activation_min, output_activation_max,
                        25, bias, out);

				/* counter reset */
				two_column_buf = runtime_buf;
			}
        }
    }            
    
    /* left-over because odd number of output pixels */
	if (two_column_buf != runtime_buf) {
		const q7_t *ker_a = kernel;
		int i;

		for (i = 0; i < output_ch; i++) {
			/* Load the accumulator with bias first */
			q31_t sum = bias[i];

			/* Point to the beginning of the im2col buffer where the input is available as a rearranged column */
			const q15_t *ip_as_col = runtime_buf;

			/* 4 multiply and accumulates are done in one loop. */
			uint16_t col_count = (input_ch * 25) >> 2;

			while (col_count) {
				q31_t ker_a1, ker_a2;
				q31_t ip_b1, ip_b2;

				ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

				ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
				sum = __SMLAD(ker_a1, ip_b1, sum);
				ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
				sum = __SMLAD(ker_a2, ip_b2, sum);

				col_count--;
			}
			/* Handle left over mac */
			col_count = input_ch * 25 & 0x3;
			while (col_count) {
				q7_t ker_a1 = *ker_a++;
				q15_t ip_b1 = *ip_as_col++;
				sum += ker_a1 * ip_b1;
				col_count--;
			}

			sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
			sum += output_offset;
			sum = MAX(sum, output_activation_min);
			sum = MIN(sum, output_activation_max);
			*out++ = (q7_t) sum;
		}
	}
    }
