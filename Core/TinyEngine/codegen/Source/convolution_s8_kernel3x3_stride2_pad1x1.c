/* This file is automatically generated */
/* ----------------------------------------------------------------------
 * Project:      TinyEngine
 * Description:  for normal convolution 3x3
 * Target ISA:  ARMv7E-M
 * Author: wmchen@mit.edu
 * -------------------------------------------------------------------- */
#include "arm_math.h"
#include "arm_nnsupportfunctions.h"
#include "arm_nnfunctions.h"
//#include "kernel_buffer.h"
#include "kernel_element.h"
#include "img2col_element.h"
#include "tinyengine_function.h"
tinyengine_status convolution_s8_kernel3x3_stride2_pad1x1(q7_t *input, const uint16_t input_x, const uint16_t input_y,
				const uint16_t input_ch, const q7_t *kernel, const int32_t *bias,
				const int32_t *output_shift, const int32_t *output_mult,
				const int32_t output_offset, const int32_t input_offset,
				const int32_t output_activation_min,
				const int32_t output_activation_max, q7_t *output,
				const uint16_t output_x, const uint16_t output_y,
				const uint16_t output_ch, q15_t *runtime_buf, q7_t pad_value)
{

    int16_t i, j, i_out_y, i_out_x, cnt;

    /* Generate two columns from the matrix multiplication */
	q15_t *two_column_buf = runtime_buf;
	q7_t *out = output;

	q15_t pad16 = pad_value;
	const int16_t inoff16 = input_offset;
	q15_t pad_out = pad16 + inoff16;
	q31_t pad_out_q15x2 = __PKHBT(pad_out, pad_out, 16);
	q31_t offset_q15x2 = __PKHBT(inoff16, inoff16, 16);
    for (i_out_y = 0; i_out_y < output_y; i_out_y++) {
		for (i_out_x = 0; i_out_x < output_x; i_out_x++) {
            /* This part implements the optimized im2col function */
			const int16_t base_idx_y = (i_out_y  * 2) - 1;
			const int16_t base_idx_x = (i_out_x  * 2) - 1;
			const q15_t *col_buffer = two_column_buf;

			//use variables
			q31_t in_q7x4;
			q31_t in_q15x2_1;
			q31_t in_q15x2_2;
			q31_t out_q15x2_1;
			q31_t out_q15x2_2;

			/* load address:8bit */
            q7_t *src0;
            q7_t *src1;
            q7_t *src2;
			/* buffer for load:16bit */
			q15_t *dst0 = &col_buffer[3 * input_ch * 0];
			q15_t *dst1 = &col_buffer[3 * input_ch * 1];
			q15_t *dst2 = &col_buffer[3 * input_ch * 2];
            int input_row_offset = input_ch * input_x;
            two_column_buf += 9 * input_ch;
			/* Computation is filed for every 2 columns */
			if (two_column_buf == runtime_buf + 2 * 9 * input_ch) {
				out = mat_mult_kernel_s8_s16(kernel,
						runtime_buf, output_ch, output_shift, output_mult,
						output_offset, output_activation_min, output_activation_max,
                        9 * input_ch, bias, out);

				/* counter reset */
				two_column_buf = runtime_buf;
			}
        }
    }            
    
    /* left-over because odd number of output pixels */
	if (two_column_buf != runtime_buf) {
		const q7_t *ker_a = kernel;
		int i;

		for (i = 0; i < output_ch; i++) {
			/* Load the accumulator with bias first */
			q31_t sum = bias[i];

			/* Point to the beginning of the im2col buffer where the input is available as a rearranged column */
			const q15_t *ip_as_col = runtime_buf;

			/* 4 multiply and accumulates are done in one loop. */
			uint16_t col_count = (input_ch * 9) >> 2;

			while (col_count) {
				q31_t ker_a1, ker_a2;
				q31_t ip_b1, ip_b2;

				ker_a = read_and_pad(ker_a, &ker_a1, &ker_a2);

				ip_b1 = arm_nn_read_q15x2_ia(&ip_as_col);
				sum = __SMLAD(ker_a1, ip_b1, sum);
				ip_b2 = arm_nn_read_q15x2_ia(&ip_as_col);
				sum = __SMLAD(ker_a2, ip_b2, sum);

				col_count--;
			}
			/* Handle left over mac */
			col_count = input_ch * 9 & 0x3;
			while (col_count) {
				q7_t ker_a1 = *ker_a++;
				q15_t ip_b1 = *ip_as_col++;
				sum += ker_a1 * ip_b1;
				col_count--;
			}

			sum = arm_nn_requantize(sum, output_mult[i], output_shift[i]);
			sum += output_offset;
			sum = MAX(sum, output_activation_min);
			sum = MIN(sum, output_activation_max);
			*out++ = (q7_t) sum;
		}
	}
    }
